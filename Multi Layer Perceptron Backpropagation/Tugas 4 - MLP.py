# -*- coding: utf-8 -*-
"""MLP.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1QPj6J_apuCuu3oQF8GqM59rkHDOAmTaH
"""

import pandas as pd  
import numpy as np  
import matplotlib.pyplot as plt  
import random
import math as m

#dataset
idx=['x1','x2','x3','x4','name']
df= pd.read_csv('iris2.csv',names=idx)

#set dataset into list
dataset= df.head(150).values.tolist()

#representating type into binary

for i in dataset:
  if (i[4]=='Iris-setosa'):
    i.append(0)
    i.append(0)
    i.append(0)
  elif (i[4]=='Iris-versicolor'):
    i.append(0)
    i.append(1)
    i.append(1)
  else:
    i.append(1)
    i.append(0)
    i.append(2)

#suffle data into random
np.random.shuffle(dataset)

#separating data
train=dataset[:120]
validasi=dataset[120:150]


#inisiasi nilai awal
errorFinal=[]
accFinal=[]
errorFinal_val=[]
accFinal_val=[]

w=[0.5,0.5,0.5,0.5]
w1=[w for i in range (4)]
wSec=[w for i in range (2)]



for i in range(4):
  for j in range (4):
    w1[i][j]=random.uniform(0,1)

for i in range(2):
  for j in range (4):
    wSec[i][j]=random.uniform(0,1)
    
    

act_h=[0.0,0.0,0.0,0.0]
act_o=[0.0,0.0]

bias=[0.5,0.5,0.5,0.5]
secbias=[0.5,0.5]



"""**Fungsi**"""

#pass forward


#sum function
def total (x,weigth,bias):
  total=0.0
  for i in range (len(x)):
    total+=x[i]+weigth[i]
    
  return total+bias

#sigmoid fuction
def activation(res):
  return (1/(1+m.exp(-res)))

#error
def error(trg,act):
  return (1/2*(m.pow((trg-act),2)))


def prediction(act):
	if act[0]<0.5 and act[1]<0.5:
		return 0
	elif act[0]>0.5 and act[1]<0.5:
		return 1
	elif act[0]<0.5 and act[1]>0.5:
		return 2
	else:
		return 3	

#backward
def dwSec(trg,out,outh):
  hasil=0
  hasil =dTotal_out(trg,out)*dOut_net(out)*outh
  return hasil

def dTotal_out(trg,out):
  return (-(trg-out))

def dOut_net(out):
  return ( out*(1-out))

def errTotal(target,output,w):
	res = 0
	res = dTotal_out(target,output) * dOut_net(output) * w
	return res

def dError_W(total,out,x):
	res = 0
	res = total * dOut_net(out) * x
	return res

def update_bias(target,output):
	res = 0
	res = dTotal_out(target,output) * dOut_net(output)
	return res

def update_bias1(total,out):
	res = 0;
	res = total * dOut_net(out)
	return res

epoch=300
act_val_h=[0,0,0,0]
act_val_o=[0,0]


total_error=[]
avg_errors_train = []
avg_errors_val = []
avg_acc_train = []
avg_acc_val = []


for i in range(epoch): #epoch
  tptn=0.0
  tptn2=0.0
  nilaiError=[0.0,0.0]
  nilaiError2=[0.0,0.0]
  
  #training
  for j in range(120):
    sumerror=0
    sumerror2=0
    
    #feedforward
    for k in range (4):
      global act_h
      act_h[k]= activation(total(train[j][0:4],w1[k],bias[k]))
      
    
    for l in range (2):
      global act_o
      act_o[l]=activation(total(act_h,wSec[l],secbias[l]))
      
      nilaiError[l]= error(train[j][l+5],act_o[l])
      sumerror+=nilaiError[l]
    
    
    if prediction(act_o)==train[j][7]:
      tptn+=1
    tptn+= (sumerror/2) 
    
    
    
    #backpropagation
    tempSecWeigth = wSec
    #to_hidden
    for out in range(2):
      for hid in range(4):
        wSec[out][hid]=wSec[out][hid]-(0.8*dwSec(train[j][out+5],act_o[out],act_h[hid]))
      secbias[out] = secbias[out] - (0.8*update_bias(train[j][out+5],act_o[out]))
 

    for cou in range(4):
          counter = 0
          for rt in range(2):
            counter += errTotal(train[j][rt+5],act_o[rt],wSec[rt][cou])
          total_error.append(counter)

    for fin in range(4):
      for fin2 in range(4):
        
        w1[fin][fin2] = w1[fin][fin2] - (0.8*dError_W(total_error[fin],act_h[fin],train[j][fin2]))

      # global bias1
      bias[fin] = bias[fin] - (0.8*update_bias1(total_error[fin],act_h[fin]))
    
  errorFinal.append(sumerror/120)
  accFinal.append(tptn/120)
    
    
  #validasi
  for i in range (30):
    for k in range (4):
      act_val_h[k]= activation(total(validasi[i][0:4],w1[k],bias[k]))
      
    
    for l in range (2):
      act_val_o[l]=activation(total(act_val_h,wSec[l],secbias[l]))
      
      nilaiError2[l]= error(validasi[i][l+5],act_val_o[l])
      sumerror2+=nilaiError2[l]
    
    
    if prediction(act_val_o)==validasi[i][7]:
      tptn2+=1
    tptn2+= (sumerror2/2) 
    
  errorFinal_val.append(sumerror/120)
  accFinal_val.append(tptn/120)

plt.figure(1)
plt.plot(errorFinal,'r-', label='train')
plt.plot(errorFinal_val, label='validasi')
plt.xlabel('epoch')
plt.ylabel('error')
plt.legend(loc='upper right')
plt.show()

plt.figure(2)
plt.plot(accFinal,'r-', label='train')
plt.plot(accFinal_val, label='validasi')
plt.xlabel('epoch')
plt.ylabel('akurasi')
plt.legend(loc='upper right')
plt.show()